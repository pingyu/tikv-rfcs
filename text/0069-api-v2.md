# TiKV API V2

## Motivation

`API V2` is a set of breaking changes that aims to solve serval issues with current RawKV (hereafter referred to as `API V1`):

1. RawKV is not safe to use along with TxnKV & TiDB. If it get solved, the three different modes can be used in the same cluster, and reduce cost of resource and maintenance. It even makes it possible that TiDB can support RawKV as the table's storage engine, and enrich TiDB's use cases.
2. RawKV TTL is controlled by TiKV configuration. Switching the configuration will cause data corruption in silence.
3. Key and value of RawKV are just raw bytes, therefore it's hard to add more metadata afterward to support more features, such as keyspace to support multi-tenant, or timestamp to support [Change Data Capture].

## Detailed Design

### New key-value codec

This RFC introduces a new key encoding to RawKV and TxnKV, and a new value encoding to RawKV, which allow RawKV to be used along with TxnKV and being flexible to add more fields to value.

Since API V2 changed the storage encoding, it will be not compatible to switch between `API V1` and `API V2` while there are non-TiDB data in TiKV. TiDB data is specially treated in order to not be affected by this change.

#### Key Encode

Once `API V2` is enabled, keys will start with either:

1. `m` and `t`: TiDB keys.
2. `x`: TxnKV keys.
3. `r`: RawKV keys.

`x`, `r` are mode prefixes that indicates which mode the key is belonging to. After mode prefix is three bytes for keyspace. So in API V2, RawKV & TxnKV keys will be encoded as `MCE(mode-prefix + keyspace + user-key) + timestamp`. `MCE` is abbreviation of [Memory Comparable Encoding]ï¼Œ which is necessary to keep the encoded keys having the same order with user keys.

Keyspace is fixed-length of 3 bytes in network byte order, and will be introduced in another RFC.

Timestamp in RawKV entries are necessary to implement [Change Data Capture] feature, which will indicate what and when data is changed.

##### Timestamp requirement

Among requests of a single key, the timestamp must be monotonic with the sequence of data flushed to disk in TiKV.

In general, if request `A` [happened before] `B`, then `Timestamp(A)` < `Timestamp(B)`. As to RawKV, we provide [Causal Consistency] by keeping order of the timestamp the same as sequence of data flush to disk.

At the same time, as RawKV doesn't provide cross-rows transaction and snapshot isolation, we treat requests of different keys as concurrent, which means that the timestamp order of two different keys would not be consistent with data flush, to improve efficiency.

##### Timestamp Generation

Timestamp is generated by TSO of PD, the same to TiDB & TxnKV. But differently, TSO is acquired by TiKV internally, to get a better overall performance and client compatibility.

To reduce latency and improve availability, TiKV will prefetch and cache a number of TSO locally. User can specify how long the TSO cache is required to tolerate fault of PD, then TiKV will calculate the size of batch according to recent QPS.

The TSO cache brings another issue, that if the latter writes of a single key happen in another store of TiKV cluster (caused by leader transfer), the TSO cache of another store must be flush to ensure that it's larger than the original store. TiKV must observe events of `leader transfer` and do the flush. Another event should be observed is `region merge`, as the leader of merged region would be on another store as to the region being merged from.

*The alternative of timestamp generation is `HLC` ([Hybrid Logical Clock]). The pros of `HLC` is being independent to availability of PD, but the cons is that it depends on local clock and [NTP], and it's also not easy to make it right (refer to [strict monotonicity](https://github.com/cockroachdb/cockroach/blob/13c5a25238ce75cfb7ff151d620e82aa44c72e27/pkg/util/hlc/doc.go#L150) in CockroachDB). All things considered, as PD is designed to be high available, and fault of PD will affect not only TSO but also other critical components (e.g, region metadata), we prefer to utilize TSO as timestamp.*

#### RawKV Value Encode

The value of RawKV `API V2` can be either:

1. `{data}{0x0}`, for values without TTL
2. `{data}{TTL expire timestamp}{0x1}`, for values with TTL
3. `{0x1}`, for values deleted

The last byte of value is used as flag. Bit `0` of flag is for TTL, if it's set, the `8` bytes just before flag is the TTL expire timestamp. Bit `1` is for deleted mark, if it's set, the entries is logical deleted (used for [Change Data Capture]).

### How to safely enable API V2

#### Upgrade from `API V1` to `API V2`

1. Upgrade TiKV, TiDB, and PD to the version that supports `API V2`.
2. Ensure that all the keys in TiKV are written by TiDB, which are prefixed with `m` or `t`. Any other data should be deleted, or else the step 3 will fail.
3. Enable `API V2` in TiKV config file and restart TiKV (user should also take the responsibility to enable `API V2` for all TiKV clients excluding TiDB).

#### Downgrade from `API V2` to `API V1`

1. Ensure that all the keys in TiKV are written by TiDB, which are prefixed with `m` or `t`. Any other data should be deleted.
2. Disable `API V2` in TiKV config file and restart TiKV (user should also take the responsibility to enable `API V1` for all TiKV clients excluding TiDB).

#### Data migration

A backup and restore tool would be provided to export data of TiKV cluster in `API V1` and convert to format of `API V2`. Then import the backup data to another TiKV cluster of `API V2`.

## Implementation Details

### kvproto

```proto
// kvrpcpb.proto

message Context {
    // ... omited other fields

    // API version implies the encode of the key and value.
    APIVersion api_version = 21;
}

// The API version the server and the client is using.
// See more details in https://github.com/tikv/rfcs/blob/master/text/0069-api-v2.md.
enum APIVersion {
    // `V1` is mainly for TiDB & TxnKV, and is not safe to use RawKV along with the others.
    V1 = 0;
    //
    // `V1TTL` is only available to RawKV.
    V1TTL = 1;
    //
    // `V2` use new encoding for RawKV & TxnKV to support more features.
    V2 = 2;
}
```

```proto
// raft_serverpb.proto

message StoreIdent {
    // ... omited other fields
    
    kvrpcpb.APIVersion api_version = 3;
}
```

```proto
// brpb.proto

message BackupMeta {
     // ... omited other fields

    kvrpcpb.APIVersion api_version = 18;
}

message BackupResponse {
    // ... omited other fields
    
    kvrpcpb.APIVersion api_version = 5;
}
```

### TiKV Server

In TiKV config file, add a new configuration `storage.api_version`.

If the API version in `StoreIdent` mismatches with `storage.api_version` in the config, it means that the user is switching the API version, therefore TiKV will check if there is any non-TiDB data in storage, and eventually save the new API version in `StoreIdent`.

If `storage.api_version=2`:

- Use the new value encoding in `RawStore` and `sst_importer`.

- Only allow RawKV to access `default` CF.

- If the request's context has `api_version=1`:
  - Reject the request unless it's a TxnKV request and the keys starting with `m` or `t`.

- If the request's context has `api_version=2`:
  - Only allow the key that has RawKV prefix for RawKV requests.
  - Only allow the key that has TxnKV prefix for TxnKV requests.

If `storage.api_version=1` & `storage.enable-ttl=true`:

- Reject all requests with `api_version=2` in the context.
- Reject all transactional requests because the raw tll encoding in V1TTL will corrupt transaction data.

If `storage.api_version=1` & `storage.enable-ttl=false`:

- Reject all requests with `api_version=2` in the context.

### TiKV Client

Provide two modes for users:

- V2:
  - Prepend `x` before TxnKV keys or prepend `r` before RawKV keys.
  - Set `api_version=2` in `kvrpcpb.Context`.
  - Disallow specifying `cf` in `RawClient`.

- V1:
  - Behaves just like current client.
  - Set `api_version=1` in `kvrpcpb.Context`.

Listed below is the compatibility matrix:

|                       | V1 Server | V1TTL Server | V2 Server |
| --------------------- | --------- | ------------ | --------- |
| V1 RawClient          | Raw       | Raw          | Error     |
| V1 RawClient with TTL | Error     | Raw          | Error     |
| V1 TxnClient          | Txn       | Error        | Error     |
| V1 TiDB               | TiDB Data | Error        | TiDB Data |
| V2 RawClient          | Error     | Error        | Raw       |
| V2 TxnClient          | Error     | Error        | Txn       |

### Garbage Collection

*To be supplemented in another PR*

### Backup and Restore

*To be supplemented in another PR*

### Change Data Capture

The details of CDC will be introduced in another RFC.

### tikv-ctl

Read `api_version` in kvdb and decode data using the corresponding version.

### TiDB

Upgrade to the latest TiKV Go Client and use `V1` mode.

## Unresolved questions

*TBD*

[Change Data Capture]: https://en.wikipedia.org/wiki/Change_data_capture
[Memory Comparable Encoding]: https://github.com/facebook/mysql-5.6/wiki/MyRocks-record-format#memcomparable-format
[Causal Consistency]: https://en.wikipedia.org/wiki/Causal_consistency
[happened before]: https://en.wikipedia.org/wiki/Happened-before
[Hybrid Logical Clock]: https://cse.buffalo.edu/tech-reports/2014-04.pdf
[NTP]: https://en.wikipedia.org/wiki/Network_Time_Protocol
